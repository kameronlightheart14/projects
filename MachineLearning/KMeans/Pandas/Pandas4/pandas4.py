# -*- coding: utf-8 -*-
"""pandas4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xx0BuQdyAbPHJHUc2mCLbjC0OCzzejmX

# Pandas 4: DatetimeIndex

## Kameron Lightheart

## Math 403

## 10/12/19
"""

# from google.colab import files
# Files needed
#     DJIA.csv
#     paychecks.csv
#     finances.csv
#     website_traffic.csv
# uploaded = files.upload()

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from datetime import datetime
from datetime import timedelta

"""# Problem 1"""

def prob1(file="DJIA.csv"):
    """
    Create DatetimeIndex for stock market data

    Returns:
        df (DataFrame): updated DataFrame of stock market data
    """
    # Read in data
    df = pd.read_csv(file)

    # Convert date column to date_time objects
    dates = pd.to_datetime(df["DATE"])

    # Drop the date column and add the saved dates as the new index
    df = df.drop(columns="DATE")
    df = df.set_index(dates, drop=True)
    df = df.dropna()
    
    def floatable(flt):
        """
        This function returns true if a value can be cast to a float
        false otherwise
        """
        try:
            float(flt)
            return True
        except:
            return False
    
    # Mask of which rows have values that can be cast to floats
    floatables = df["VALUE"].apply(floatable)
    
    # Apply the mask
    return df[floatables].astype(float)

# prob1()

"""# Problem 2"""

def prob2(file="paychecks.csv"):
    """
    Create data_range for index of paycheck data

    Returns:
        df (DataFrame): DataFrame of paycheck data
    """
    # Read in the data, which has no column headers
    df = pd.read_csv(file, index_col=0, header=None)

    # Number of rows / 2, with a buffer that will be cut off later
    n = (len(df) // 2) + 4

    # 1st Friday of every month
    dates1 = pd.date_range(start='3/13/2008', periods=n, freq="WOM-1FRI")
    # 3nd Friday of every month
    dates2 = pd.date_range(start='3/13/2008', periods=n, freq="WOM-3FRI")
    # Union 1st and 3rd Fridays of every month
    dates = dates1.union(dates2)[:93]

    # Set the First and 3rd Fridays as the new index
    df = df.reset_index()
    df = df.set_index(dates, drop=False)
    return df

# prob2()

"""# Problem 3"""

def prob3(file="finances.csv"):
    """
    Create period range as index

    Returns:
        df (DataFrame): DataFrame of finance data
    """
    # Read in the data
    df = pd.read_csv(file, index_col=0)

    # Quarter periods with Fiscal year starting in October
    dates_period = pd.period_range(start='9/01/1978', freq="Q-SEP", periods=len(df))
    # Convert period_range to date_time objects
    dates = dates_period.to_timestamp(how="end")
    
    # Set the index to those quarter date values
    df = df.reset_index()
    df = df.set_index(dates, drop=False)
    return df

# prob3()

"""# Problem 4"""

def prob4(file="website_traffic.csv"):
    """
    Get average number of users entering a site each
    minute and each hour

    Returns:
        minutes (df): DataFrame containing the number
                      of users entering a website each minutes
        hours (df): DataFrame containing the number of users
                    entering a website each hour
    """
    # Read in data
    df = pd.read_csv(file)
    
    # Compute duration spent on website
    df.ENTER =  pd.to_datetime(df["ENTER"])
    df.LEAVE =  pd.to_datetime(df["LEAVE"])
    df['DURATION'] = (df.LEAVE - df.ENTER).apply(lambda x : x.total_seconds())
    df = df.set_index("ENTER")
    
    # Downsample to minutes and hours
    minutes = df.resample('T').agg("mean")
    hours = df.resample('H').agg("mean")
    
    return minutes, hours

# prob4()

"""# Problem 5"""

def prob5(file="DJIA.csv"):
    """
    Find days with maximum and minimum change in stock price
    
    Returns:
        max_day (<M8[ns]): index of maximum change
        min_day (<M8[ns]): index of minimum change
    """
    # Get the formatted data from prob1()
    df = prob1()
    
    # Compute the maximum gain and loss days
    max_gain = (df.diff()).idxmax()
    max_loss = (df.diff()).idxmin()
    
    return max_gain, max_loss

# prob5()

"""# Problem 6"""

def prob6():
    """
    Calculate and plot the rolling and exponential averages
    for window and span size 30, 120, and 365

    Returns:
        mins_roll (list): list of minimum values of rolling average
                          for window size 30, 120, and 365
        mins_exp (list): list of minimum values of exponential average
                         for span size 30, 120, and 365
    """
    # Get the formatted data from problem 1
    df = prob1()
    windows = [30, 120, 365]
    rollings = []
    exps = []
    
    # Loop through each window size and plot the rolling and exp avg
    for window in windows:
        # Actual Data
        ax = df.plot(color="gray", lw=.3, label="Actual Data")
        
        # Rolling average data
        rolling = df.rolling(window=window).mean()
        rollings.append(rolling["VALUE"].min())
        rolling.plot(color='r', lw=1, ax=ax) 
        
        # Exponential Average
        exp = df.ewm(span=window).mean()
        exps.append(exp["VALUE"].min())
        exp.plot(color='g', lw=1, ax=ax) 
        
        ax.set_title("Window and Span of " + str(window))
        ax.legend(["Actual Data", "Rolling Average", "Exponential Average"], loc="lower right")

    return rollings, exps
# prob6()

